<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Drag&Drop DICOM - X3DOM - 2Color TF Editor.</title>
    <script type="text/javascript" src="jquery-3.0.0.js"></script>
    <script type="text/javascript" src="jquery-migrate-1.4.1.min.js"></script>
    <script type="text/javascript" src="dicomParser.js"></script>
    <script type="text/javascript" src="cornerstone.js"></script>
    <script type="text/javascript" src="cornerstoneWADOImageLoader.js"></script>
    <script type="text/javascript" src="x3dom-full.js"></script>
    <script type="text/javascript" src="raphael.min.js"></script>
    <script type="text/javascript" src="dicom2atlas.js"></script>
    <script type="text/javascript" src="dat.gui.min.js"></script>
    <script type="text/javascript" src="tinycolor.js"></script>
    <!--script type="text/javascript" src="two.min.js"></script-->

    <script type="text/javascript">
        // Prevents the drop target element from triggering default action on dropped files (download)
        function divallowdrop(event) {
            event.preventDefault();
        }

        var CURRENT_FILES;
        // Handles multiple DICOM files drop on element and converts them into an atlas
        function divondrop(event) {
            // Also needed to prevent the drop target element from triggering default action on dropped files (download)
            event.stopPropagation();
            event.preventDefault();

            // Get the number of slices info, to update the ImageTextureAtlas
            CURRENT_FILES = event.dataTransfer.files;
            var numberOfSlices = event.dataTransfer.files.length;
            var slicesOverX = Math.ceil(Math.sqrt(numberOfSlices)),
                    slicesOverY = slicesOverX;

            // Reset the X3D scene declaration, and reload the scene;
            resetScene(numberOfSlices, slicesOverX, slicesOverY);

            // Resulting canvas containing atlas
            var voxelCanvas = document.getElementById("voxelCanvas");
            var voxelContext = voxelCanvas.getContext("2d");

            //Now process the dropped files with dicomParser
            filesToAtlas(event.dataTransfer.files, voxelContext, voxelCanvas.width, voxelCanvas.height, document.getElementById("InvisibleDiv"));
        }

        /*
         * Reset all the scene declaration and reload
         */
        function resetScene(numberOfSlices, slicesOverX, slicesOverY) {
            var myX3D = document.getElementById("MyX3D");
            var myX3DPlaceHolder = document.getElementById("MyX3DPlaceHolder");
            //var ORIGINAL_X3DNODE_HTML = myX3DPlaceHolder.innerHTML;// NOTE: If we get it here everything goes black!
            myX3D.parentNode.removeChild(myX3D);
            // Replace original numberOfSlices/slicesOverX/slicesOverY values with current ones
            myX3DPlaceHolder.innerHTML = ORIGINAL_X3DNODE_HTML
                    .replace(/numberOfSlices=.[\d]*./i, "numberOfSlices='" + numberOfSlices + "'")
                    .replace(/slicesOverX=.[\d]*./i, "slicesOverX='" + slicesOverX + "'")
                    .replace(/slicesOverY=.[\d]*./i, "slicesOverY='" + slicesOverY + "'");
            // Force reload of scene
            x3dom.reload();
        }


        function updateLinearTF(value) {
            USE_TF_FROMFILE = false;
            var tfCanvas = document.getElementById("tfCanvas");
            var ctxTfCanvas = tfCanvas.getContext("2d");

            ctxTfCanvas.clearRect(0, 0, tfCanvas.width, tfCanvas.height);
            var gradient = ctxTfCanvas.createLinearGradient(0, 0, tfCanvas.width, 0);
            gradient.addColorStop(0, tinycolor(x3domcontrols.colorMin).setAlpha(x3domcontrols.opacityMin).toRgbString());
            gradient.addColorStop(1, tinycolor(x3domcontrols.colorMax).setAlpha(x3domcontrols.opacityMax).toRgbString());
            ctxTfCanvas.fillStyle = gradient;
            ctxTfCanvas.fillRect(0, 0, tfCanvas.width, tfCanvas.height);

            // Refreshes X3DOM to take into account new TF contents
            document.getElementById("voxelAtlas")._x3domNode.invalidateGLObject();
        }

        function updateWL(value) {
            if (CURRENT_FILES !== undefined) {
                var voxelCanvas = document.getElementById("voxelCanvas");
                var voxelContext = voxelCanvas.getContext("2d");
                filesToAtlas(CURRENT_FILES, voxelContext, voxelCanvas.width, voxelCanvas.height, document.getElementById("InvisibleDiv"), x3domcontrols.windowCenter, x3domcontrols.windowWidth);
            }
        }

        var x3domcontrols;
        var ORIGINAL_X3DNODE_HTML;
        function bodyonload() {
            // Set handlers for required drop events
            document.getElementById("DropArea").addEventListener("drop", divondrop);
            document.getElementById("DropArea").addEventListener("dragover", divallowdrop);

            //readTF("TeethJawsSkin_OSIRIX_ONLY.tf");

            document.getElementById("tfCanvas").getContext("2d").drawImage(document.getElementById("hiddenBWTF"), 0, 0, 256, 10);

            x3domcontrols = new X3DOMControls();
            var guiTF = new dat.GUI({load: JSON, preset: 'Default'});

            var linearTF = guiTF.addFolder('Linear TF');
            var colorMin = linearTF.addColor(x3domcontrols, 'colorMin');
            var opacityMin = linearTF.add(x3domcontrols, 'opacityMin', 0.0, 1.0, 0.1);
            var colorMax = linearTF.addColor(x3domcontrols, 'colorMax');
            var opacityMax = linearTF.add(x3domcontrols, 'opacityMax', 0.0, 1.0, 0.1);
            linearTF.open();

            colorMin.onChange(updateLinearTF);
            opacityMin.onFinishChange(updateLinearTF);
            colorMax.onChange(updateLinearTF);
            opacityMax.onFinishChange(updateLinearTF);

            guiTF.remember(x3domcontrols);

            var guiWL = new dat.GUI();
            var wlFolder = guiWL.addFolder('W/L');
            var windowCenter = wlFolder.add(x3domcontrols, 'windowCenter', -2500, 5000, 1).listen();
            var windowWidth = wlFolder.add(x3domcontrols, 'windowWidth', 0, 7500, 1).listen();
            windowCenter.onFinishChange(updateWL);
            windowWidth.onFinishChange(updateWL);
            wlFolder.open();
        }
        window.addEventListener("load", bodyonload, false);
    </script>
</head>
<body>

<!-- This DIV is the area where to drop the DICOM files -->
Drop something straight into the following X3DOM canvas.
<div id="DropArea">
    <div id="MyX3DPlaceHolder">
        <!-- X3DOM node -->
        <X3D id="MyX3D" xmlns='http://www.web3d.org/specifications/x3d-namespace' showStat='false' showLog='false'
             width='1024px' height='640px'>
            <Scene id="X3DScene">
                <Background skyColor='0.3 0.3 0.3'></Background>
                <Viewpoint description='Default' zNear='0.0001' zFar='100'></Viewpoint>
                <Transform id="volumeTransform">
                    <VolumeData id='volume' dimensions='4.0 4.0 4.0'>
                        <ImageTextureAtlas containerField='voxels' id="voxelAtlas" numberOfSlices='1' slicesOverX='1'
                                           slicesOverY='1' hideChildren="true">
                            <canvas width='4096' height='4096' id='voxelCanvas'></canvas>
                        </ImageTextureAtlas>
                        <OpacityMapVolumeStyle lightFactor='1.2' opacityFactor='6.0'>
                            <ImageTexture containerField='transferFunction' hideChildren="true">
                                <canvas width='256' height='10' id='tfCanvas'></canvas>
                            </ImageTexture>
                        </OpacityMapVolumeStyle>
                    </VolumeData>
                </Transform>
            </Scene>
        </X3D>
    </div>
</div>
<script type="application/javascript">
    // Here we pick up the original HTML Code of our X3D Node
    ORIGINAL_X3DNODE_HTML = document.getElementById("MyX3DPlaceHolder").innerHTML;
</script>
<div id="histogramHolder" style="width:1024px;height:200px;display:none;">
    Here goes the histogram:
    <canvas id="histcanvas" width="255" height="100"></canvas>
</div>

<!-- The following div is made invisible in order to hide temporary images needed for computation -->
<div id="InvisibleDiv" style="display:block;background:#888888;width:50%;height:50%">
    <canvas width='256' height='10' id="tfTmpCanvas"></canvas>
    <canvas width='32' height='32' id="tmpCanvas"></canvas>
    <img id="hiddenBWTF" src="transfer.png"/>
</div>

<div id="canvas"></div>
<div id="holder"></div>
<div id="blabla"></div>
<input id="html5colorpicker" value="#ff0000" type="color">

<script type="application/javascript">
    var W = 1024;
    var H = 150;
    var r = Raphael("holder", W, H);
    var values = [];
    var gradientColors=[];
    var N_CONTROL_POINTS = 10;
    var maxOpacity = 1.0;
    for (var i = 0; i < N_CONTROL_POINTS; i++) {
        values.push((i+1)*0.1*maxOpacity);
        //gradientColors.push("hsb(240°, 0, "+(i+1)*0.1+")");
        var gray = 255*(i+1)*0.1;
        gradientColors.push("rgb("+gray+","+gray+","+gray+")");
    }

    function translate(x, y) {
        return [ W / (values.length - 1) * x, H - H / maxOpacity * y ];
    }

    function drawPath() {
        var p = ["M", X[0], Y[0], "R"];
        for (var j = 1, jj = X.length; j < jj; j++) {
            p.push(X[j], Y[j]);
        }
        var subaddon = "L" + W + "," + H + ",0," + H + "z";
        path.attr({path: p});
        sub.attr({path: p + subaddon});
    }

    //var p = [["M"].concat(translate(0, values[0]))];
    var colorLeft = "hsb(240°, 0, 0)";
    var colorRight = "hsb(240°, 0, 1)";
    var colorInactivePoint = "hsb(240°, 1, 1)";
    var colorLine = "hsb(200°, 0.5, 1.0)";
    var colorActivePoint = "hsb(140°, 1, 1)";
    var colorGradient = [0].concat(gradientColors).join("-");
    var X = [];
    var Y = [];
    var blankets = r.set();
    var buttons = r.set();
    var w = (W - 60) / values.length;
    var isDrag = -1;
    var start = null;
    var sub = r.path().attr({stroke: "none", fill: colorGradient, opacity: 0});
    var path = r.path().attr({stroke: colorLine, "stroke-width": 2});
    var unhighlight = function () {};

    var ii = values.length - 1;
    for (i = 0; i < ii; i++) {
        var xy = translate(i, values[i]);
        var xy1 = translate(i + 1, values[i + 1]);
        var f;
        X[i] = xy[0];
        Y[i] = xy[1];
        (f = function (i, xy) {
            buttons.push(r.circle(xy[0], xy[1], 5).attr({fill: colorInactivePoint, stroke: "none"}));
            blankets.push(r.circle(xy[0], xy[1], w / 2).attr({
                stroke: "none",
                fill: "#fff",
                opacity: 0
            }).mouseover(function () {
                if (isDrag + 1) {
                    unhighlight = function () {
                    };
                } else {
                    buttons.items[i].animate({r: 10,fill: colorActivePoint}, 200);
                }
            }).mouseout(function () {
                if (isDrag + 1) {
                    unhighlight = function () {
                        buttons.items[i].animate({r: 5,fill: colorInactivePoint}, 200);
                    };
                } else {
                    buttons.items[i].animate({r: 5,fill: colorInactivePoint}, 200);
                }
            }).drag(function (dx, dy) {
                var start = this.start;
                start && update(start.i, start.p + dy);
            }, function (x, y) {
                this.start = {i: i, m: y, p: Y[i]};
            }).dblclick(function(){
                gradientColors[i] = document.getElementById("html5colorpicker").value;
                sub.animate({fill : [0].concat(gradientColors).join("-")},100);
                setNewTF();
            }));
            blankets.items[blankets.items.length - 1].node.style.cursor = "move";
        })(i, xy);
        if (i == ii - 1) {
            f(i + 1, xy1);
        }
    }
    xy = translate(ii, values[ii]);
    X.push(xy[0]);
    Y.push(xy[1]);

    drawPath();

    var r1 = Raphael("blabla", 256, 10);
    function setNewTF(){
        r1.clear();
        var fill = [];
        for (var i = 0; i < values.length; i++) {
            var color = Raphael.color(gradientColors[i]);
            fill.push("rgba("+color.r+","+color.g+","+color.b+","+values[i]+")");
        }
        r1.path("M0,10L0,0L256,0L256,10z").attr({stroke: "none", fill: [0].concat(fill).join("-")});

        var DOMURL = window.URL || window.webkitURL || window;
        var img = new Image();
        var url = DOMURL.createObjectURL(new Blob([r1.canvas.parentNode.innerHTML], {type: 'image/svg+xml;charset=utf-8'}));
        img.onload = function () {
            document.getElementById("tfTmpCanvas").getContext("2d").drawImage(img, 0, 0);
            DOMURL.revokeObjectURL(url);
        }
        img.src = url;
        USE_TF_FROMFILE = true;
        applyColor();
    }

    // Handle when a point gets moved
    var update = function (i, d) {
        (d > H ) && (d = H );
        (d < 0) && (d = 0);
        Y[i] = d;
        values[i] = -1 / maxOpacity*((Y[i]/H)-1);
        drawPath();
        buttons.items[i].attr({cy: d});
        blankets.items[i].attr({cy: d});
        //console.log(values);
        setNewTF();
        //r.safari();
    };

</script>

</body>
</html>
