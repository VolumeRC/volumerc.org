<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Drag&Drop DICOM - X3DOM - 2Color TF Editor.</title>
    <script type="text/javascript" src="jquery-3.0.0.js"></script>
    <script type="text/javascript" src="jquery-migrate-1.4.1.min.js"></script>
    <script type="text/javascript" src="dicomParser.js"></script>
    <script type="text/javascript" src="cornerstone.js"></script>
    <script type="text/javascript" src="cornerstoneWADOImageLoader.js"></script>
    <script type="text/javascript" src="x3dom-full.js"></script>
    <script type="text/javascript" src="raphael.min.js"></script>
    <script type="text/javascript" src="dicom2atlas.js"></script>
    <script type="text/javascript" src="dat.gui.min.js"></script>
    <script type="text/javascript" src="tinycolor.js"></script>

    <script type="text/javascript">
        // Prevents the drop target element from triggering default action on dropped files (download)
        function divallowdrop(event) {
            event.preventDefault();
        }

        var CURRENT_FILES;
        // Handles multiple DICOM files drop on element and converts them into an atlas
        function divondrop(event) {
            // Also needed to prevent the drop target element from triggering default action on dropped files (download)
            event.stopPropagation();
            event.preventDefault();

            // Get the number of slices info, to update the ImageTextureAtlas
            CURRENT_FILES = event.dataTransfer.files;
            var numberOfSlices = event.dataTransfer.files.length;
            var slicesOverX = Math.ceil(Math.sqrt(numberOfSlices)),
                    slicesOverY = slicesOverX;

            // Reset the X3D scene declaration, and reload the scene;
            resetScene(numberOfSlices, slicesOverX, slicesOverY);

            // Resulting canvas containing atlas
            var voxelCanvas = document.getElementById("voxelCanvas");
            var voxelContext = voxelCanvas.getContext("2d");

            //Now process the dropped files with dicomParser
            filesToAtlas(event.dataTransfer.files, voxelContext, voxelCanvas.width, voxelCanvas.height, document.getElementById("InvisibleDiv"));
        }

        /*
         * Reset all the scene declaration and reload
         */
        function resetScene(numberOfSlices, slicesOverX, slicesOverY) {
            var myX3D = document.getElementById("MyX3D");
            var myX3DPlaceHolder = document.getElementById("MyX3DPlaceHolder");
            //var ORIGINAL_X3DNODE_HTML = myX3DPlaceHolder.innerHTML;// NOTE: If we get it here everything goes black!
            myX3D.parentNode.removeChild(myX3D);
            // Replace original numberOfSlices/slicesOverX/slicesOverY values with current ones
            myX3DPlaceHolder.innerHTML = ORIGINAL_X3DNODE_HTML
                    .replace(/numberOfSlices=.[\d]*./i, "numberOfSlices='" + numberOfSlices + "'")
                    .replace(/slicesOverX=.[\d]*./i, "slicesOverX='" + slicesOverX + "'")
                    .replace(/slicesOverY=.[\d]*./i, "slicesOverY='" + slicesOverY + "'");
            // Force reload of scene
            x3dom.reload();
        }


        function updateWL(value) {
            if (CURRENT_FILES !== undefined) {
                var voxelCanvas = document.getElementById("voxelCanvas");
                var voxelContext = voxelCanvas.getContext("2d");
                filesToAtlas(CURRENT_FILES, voxelContext, voxelCanvas.width, voxelCanvas.height, document.getElementById("InvisibleDiv"), x3domcontrols.windowCenter, x3domcontrols.windowWidth);
            }
        }

        //var x3domcontrols;
        var ORIGINAL_X3DNODE_HTML;
        function bodyonload() {
            // Set handlers for required drop events
            document.getElementById("DropArea").addEventListener("drop", divondrop);
            document.getElementById("DropArea").addEventListener("dragover", divallowdrop);

            //readTF("TeethJawsSkin_OSIRIX_ONLY.tf");

            document.getElementById("tfCanvas").getContext("2d").drawImage(document.getElementById("hiddenBWTF"), 0, 0, 256, 10);

            //x3domcontrols = new X3DOMControls();

            var guiWL = new dat.GUI();
            var wlFolder = guiWL.addFolder('W/L');
            var windowCenter = wlFolder.add(x3domcontrols, 'windowCenter', -2500, 5000, 1).listen();
            var windowWidth = wlFolder.add(x3domcontrols, 'windowWidth', 0, 7500, 1).listen();
            windowCenter.onFinishChange(updateWL);
            windowWidth.onFinishChange(updateWL);
            wlFolder.open();
        }
        window.addEventListener("load", bodyonload, false);
    </script>
</head>
<body>

<!-- This DIV is the area where to drop the DICOM files -->
Drop something straight into the following X3DOM canvas.
<div id="DropArea">
    <div id="MyX3DPlaceHolder">
        <!-- X3DOM node -->
        <X3D id="MyX3D" xmlns='http://www.web3d.org/specifications/x3d-namespace' showStat='false' showLog='false'
             width='1024px' height='640px'>
            <Scene id="X3DScene">
                <Background skyColor='0.3 0.3 0.3'></Background>
                <Viewpoint description='Default' zNear='0.0001' zFar='100'></Viewpoint>
                <Transform id="volumeTransform">
                    <VolumeData id='volume' dimensions='4.0 4.0 4.0'>
                        <ImageTextureAtlas containerField='voxels' id="voxelAtlas" numberOfSlices='1' slicesOverX='1'
                                           slicesOverY='1' hideChildren="true">
                            <canvas width='4096' height='4096' id='voxelCanvas'></canvas>
                        </ImageTextureAtlas>
                        <OpacityMapVolumeStyle lightFactor='1.2' opacityFactor='6.0'>
                            <ImageTexture containerField='transferFunction' hideChildren="true">
                                <canvas width='256' height='10' id='tfCanvas'></canvas>
                            </ImageTexture>
                        </OpacityMapVolumeStyle>
                    </VolumeData>
                </Transform>
            </Scene>
        </X3D>
    </div>
</div>
<script type="application/javascript">
    // Here we pick up the original HTML Code of our X3D Node
    ORIGINAL_X3DNODE_HTML = document.getElementById("MyX3DPlaceHolder").innerHTML;
</script>
<div id="histogramHolder" style="width:1024px;height:200px;display:none;">
    Here goes the histogram:
    <canvas id="histcanvas" width="255" height="100"></canvas>
</div>

<!-- The following div is made invisible in order to hide temporary images needed for computation -->
<div id="InvisibleDiv" style="display:none;background:#888888;width:50%;height:50%">
    <canvas width='256' height='10' id="tfTmpCanvas"></canvas>
    <canvas width='32' height='32' id="tmpCanvas"></canvas>
    <img id="hiddenBWTF" src="transfer.png"/>
</div>

<div id="canvas"></div>
<div id="holder"></div>
<div id="blabla"></div>
<input id="html5colorpicker" value="#ff0000" type="color">

<script type="application/javascript">
    function createTFEditor(nControlPoints){
        var r = Raphael("holder", 1024, 150);
        var W = r.width;
        var H = r.height;
        var values = [];
        var gradientColors=[];
        var MAX_OPACITY = 1.0;
        var colorInactivePoint = "hsb(240°, 1, 1)";
        var colorLine = "hsb(200°, 0.5, 1.0)";
        var colorActivePoint = "hsb(140°, 1, 1)";
        var X = [];
        var Y = [];
        var blankets = r.set();
        var buttons = r.set();
        var isDrag = -1;
        var start = null;
        var unhighlight = function () {};
        var colorGradient;
        var w;
        var sub;
        var path;
        function initValues(){
            var gray = 0;
            for (var i = 0; i < nControlPoints; i++) {
                values.push((i+1)*MAX_OPACITY/nControlPoints);
                gray = 255*(i+1)/nControlPoints;
                gradientColors.push("rgb("+gray+","+gray+","+gray+")");
            }
            colorGradient = [0].concat(gradientColors).join("-");
            w = W / values.length;
            sub = r.path().attr({stroke: "none", fill: colorGradient, opacity: 0});
            path = r.path().attr({stroke: colorLine, "stroke-width": 2});
        }

        function translate(x, y) {
            return [ W / (values.length - 1) * x, H - H / MAX_OPACITY * y ];
        }

        function drawPath(X,Y,W,H) {
            var p = ["M", X[0], Y[0], "R"];
            for (var j = 1; j < X.length; j++) {
                p.push(X[j], Y[j]);
            }
            var subaddon = "L" + W + "," + H + ",0," + H + "z";
            path.attr({path: p});
            sub.attr({path: p + subaddon});
        }


        function initPath() {
            var ii = values.length - 1;
            for (i = 0; i < ii; i++) {
                var xy = translate(i, values[i]);
                var xy1 = translate(i + 1, values[i + 1]);
                var f;
                X[i] = xy[0];
                Y[i] = xy[1];
                (f = function (i, xy) {
                    buttons.push(r.circle(xy[0], xy[1], 5).attr({fill: colorInactivePoint, stroke: "none"}));
                    blankets.push(r.circle(xy[0], xy[1], w / 2).attr({
                        stroke: "none",
                        fill: "#fff",
                        opacity: 0
                    }).mouseover(function () {
                        if (isDrag + 1) {
                            unhighlight = function () {
                            };
                        } else {
                            buttons.items[i].animate({r: 10,fill: colorActivePoint}, 200);
                        }
                    }).mouseout(function () {
                        if (isDrag + 1) {
                            unhighlight = function () {
                                buttons.items[i].animate({r: 5,fill: colorInactivePoint}, 200);
                            };
                        } else {
                            buttons.items[i].animate({r: 5,fill: colorInactivePoint}, 200);
                        }
                    }).drag(function (dx, dy) {
                        var start = this.start;
                        start && update(start.i, start.p + dy);
                    }, function (x, y) {
                        this.start = {i: i, m: y, p: Y[i]};
                    }).dblclick(function(){
                        gradientColors[i] = document.getElementById("html5colorpicker").value;
                        sub.animate({fill : [0].concat(gradientColors).join("-")},100);
                        setNewTF();
                    }));
                    blankets.items[blankets.items.length - 1].node.style.cursor = "move";
                })(i, xy);
                if (i == ii - 1) {
                    f(i + 1, xy1);
                }
            }
            xy = translate(ii, values[ii]);
            X.push(xy[0]);
            Y.push(xy[1]);
        }

        function setNewTF(){
            //SINCE RAPHAEL IS SVG AND NOT CANVAS WE CAN'T COPY STRAIGHT INTO A CANVAS
            var tfTmpCanvas = document.getElementById("tfTmpCanvas");
            var ctx = tfTmpCanvas.getContext("2d");
            ctx.clearRect(0, 0, tfTmpCanvas.width, tfTmpCanvas.height);
            var rangeWidth = Math.floor(tfTmpCanvas.width/nControlPoints);
            for (var i = 1; i < values.length; i++) {
                var color1 = Raphael.color(gradientColors[i-1]);
                var color2 = Raphael.color(gradientColors[i]);
                //"rgba("+color.r+","+color.g+","+color.b+","+values[i]+")";

                var grd = ctx.createLinearGradient((i-1)*rangeWidth, 0, i*rangeWidth, tfTmpCanvas.height);
                grd.addColorStop(0, "rgba(" + Math.floor(color1.r) + "," + Math.floor(color1.g) + "," + Math.floor(color1.b) + "," + values[i-1] + ")");
                grd.addColorStop(1, "rgba(" + Math.floor(color2.r) + "," + Math.floor(color2.g) + "," + Math.floor(color2.b) + "," + values[i] + ")");
                ctx.fillStyle = grd;
                ctx.fillRect((i-1)*rangeWidth, 0, i*rangeWidth, tfTmpCanvas.height);
            }

            USE_TF_FROMEDITOR = true;
            applyColor();
        }

        // Handle when a point gets moved
        var update = function (i, d) {
            (d > H ) && (d = H );
            (d < 0) && (d = 0);
            Y[i] = d;
            values[i] = -1 / MAX_OPACITY*((Y[i]/H)-1);
            drawPath(X,Y,W,H);
            buttons.items[i].attr({cy: d});
            blankets.items[i].attr({cy: d});
            setNewTF();
        };
        initValues();
        initPath();
        drawPath(X,Y,W,H);

        return r;
    }

    var r = createTFEditor(16);
    r.clear();r.remove();
    r = createTFEditor(10);

</script>

</body>
</html>
