<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Drag&Drop DICOM - X3DOM - 2Color TF Editor.</title>
    <script type="text/javascript" src="../js/jquery-3.0.0.js"></script>
    <script type="text/javascript" src="../js/jquery-migrate-1.4.1.min.js"></script>
    <script type="text/javascript" src="../js/dicomParser.js"></script>
    <script type="text/javascript" src="../js/cornerstone.js"></script>
    <script type="text/javascript" src="../js/cornerstoneWADOImageLoader.js"></script>
    <script type="text/javascript" src="../js/x3dom-full.js"></script>
    <script type="text/javascript" src="../js/raphael.min.js"></script>
    <script type="text/javascript" src="../js/dicom2atlas.js"></script>
    <script type="text/javascript" src="../js/dat.gui.min.js"></script>
    <script type="text/javascript" src="../js/tinycolor.js"></script>

    <!--
        <link href="http://insightsoftwareconsortium.github.io/ITKAnisotropicDiffusionLBR/css/pace.css" rel="stylesheet">
        <script type="text/javascript" src="http://insightsoftwareconsortium.github.io/ITKAnisotropicDiffusionLBR/js/pace.min.js"></script>
    -->
    <link href="ITKAnisotropicDiffusionLBR/css/bootstrap.min.css" rel="stylesheet">
    <link href="ITKAnisotropicDiffusionLBR/css/bootstrap-theme.min.css" rel="stylesheet">
    <script type="text/javascript" src="ITKAnisotropicDiffusionLBR/js/bootstrap.min.js" async></script>
    <link href="ITKAnisotropicDiffusionLBR/css/bootstrap-slider.min.css" rel="stylesheet">
    <script type="text/javascript" src="ITKAnisotropicDiffusionLBR/js/bootstrap-slider.min.js" async></script>

    <script type="text/javascript" src="EmscriptenDebug.js"></script>
    <!--script type="text/javascript" src="CoherenceEnhancingDiffusion.js"></script-->
    <!--script type="text/javascript" src="CoherenceEnhancingDiffusion.pretty.js"></script-->
    <!--script type="text/javascript" src="CoherenceEnhancingDiffusion.1.js"></script-->
    <!--script type="text/javascript" src="CoherenceEnhancingDiffusion.1.pretty.js"></script-->
    <!--script type="text/javascript" src="CoherenceEnhancingDiffusion.2.js"></script-->
    <!--script type="text/javascript" src="ConvertAndResample.js" ></script-->
    <!--script type="text/javascript" src="CTThresholdSegmentation.js" ></script-->
    <script type="text/javascript" src="CTThresholdSegmentationAll.js"></script>
    <script type="text/javascript" src="FileSaver.min.js"></script>
    <script type="text/javascript" src="Runner.js"></script>

    <!---->

    <script type="text/javascript">
        // Prevents the drop target element from triggering default action on dropped files (download)
        function divallowdrop(event) {
            event.preventDefault();
        }

        var CURRENT_FILES;
        
        function segmentedToAtlas(output_files){
            // Resulting canvas containing atlas
            var segmentCanvas = document.getElementById("segmentCanvas");
            var segmentContext = segmentCanvas.getContext("2d");

            //Now process the dropped files with dicomParser
            filesToAtlas(output_files, segmentContext, segmentCanvas.width, segmentCanvas.height, document.getElementById("InvisibleDiv"), 127, 256);
        }
        
        // Handles multiple DICOM files drop on element and converts them into an atlas
        function divondrop(event) {
            // Also needed to prevent the drop target element from triggering default action on dropped files (download)
            event.stopPropagation();
            event.preventDefault();

            document.getElementById("input-previews").innerHTML = "";
            document.getElementById("output-previews").innerHTML = "";
            Runner.filter.setCallbackCompletion(segmentedToAtlas);
            Runner.filter.setInputFile(event.dataTransfer.files);

            // Get the number of slices info, to update the ImageTextureAtlas
            CURRENT_FILES = event.dataTransfer.files;
            var numberOfSlices = event.dataTransfer.files.length;
            var slicesOverX = Math.ceil(Math.sqrt(numberOfSlices)),
                slicesOverY = slicesOverX;

            // Reset the X3D scene declaration, and reload the scene;
            resetScene(numberOfSlices, slicesOverX, slicesOverY);

            // Resulting canvas containing atlas
            var voxelCanvas = document.getElementById("voxelCanvas");
            var voxelContext = voxelCanvas.getContext("2d");

            //Now process the dropped files with dicomParser
            filesToAtlas(event.dataTransfer.files, voxelContext, voxelCanvas.width, voxelCanvas.height, document.getElementById("InvisibleDiv"));
        }

        /*
         * Reset all the scene declaration and reload
         */
        function resetScene(numberOfSlices, slicesOverX, slicesOverY) {
            var myX3D = document.getElementById("MyX3D");
            var myX3DPlaceHolder = document.getElementById("MyX3DPlaceHolder");
            //var ORIGINAL_X3DNODE_HTML = myX3DPlaceHolder.innerHTML;// NOTE: If we get it here everything goes black!
            myX3D.parentNode.removeChild(myX3D);
            // Replace original numberOfSlices/slicesOverX/slicesOverY CURRENT_TF_VALUES with current ones
            myX3DPlaceHolder.innerHTML = ORIGINAL_X3DNODE_HTML
                .replace(/numberOfSlices=.[\d]*./i, "numberOfSlices='" + numberOfSlices + "'")
                .replace(/slicesOverX=.[\d]*./i, "slicesOverX='" + slicesOverX + "'")
                .replace(/slicesOverY=.[\d]*./i, "slicesOverY='" + slicesOverY + "'");
            // Force reload of scene
            x3dom.reload();
        }


        function updateWL(value) {
            if (CURRENT_FILES !== undefined) {
                var voxelCanvas = document.getElementById("voxelCanvas");
                var voxelContext = voxelCanvas.getContext("2d");
                filesToAtlas(CURRENT_FILES, voxelContext, voxelCanvas.width, voxelCanvas.height, document.getElementById("InvisibleDiv"), x3domcontrols.windowCenter, x3domcontrols.windowWidth);
            }
        }
        function setNewTF(values, gradientColors) {
            //SINCE RAPHAEL IS SVG AND NOT CANVAS WE CAN'T COPY STRAIGHT INTO A CANVAS
            var tfTmpCanvas = document.getElementById("tfTmpCanvas");
            var ctx = tfTmpCanvas.getContext("2d");
            ctx.clearRect(0, 0, tfTmpCanvas.width, tfTmpCanvas.height);
            var rangeWidth = Math.floor(tfTmpCanvas.width / x3domcontrols.numberOfHistogramPoints);
            for (var i = 1; i < values.length; i++) {
                var color1 = Raphael.color(gradientColors[i - 1]);
                var color2 = Raphael.color(gradientColors[i]);
                //"rgba("+color.R_TF_EDITOR+","+color.g+","+color.b+","+CURRENT_TF_VALUES[i]+")";

                var grd = ctx.createLinearGradient((i - 1) * rangeWidth, 0, i * rangeWidth, tfTmpCanvas.height);
                grd.addColorStop(0, "rgba(" + Math.floor(color1.r) + "," + Math.floor(color1.g) + "," + Math.floor(color1.b) + "," + values[i - 1] + ")");
                grd.addColorStop(1, "rgba(" + Math.floor(color2.r) + "," + Math.floor(color2.g) + "," + Math.floor(color2.b) + "," + values[i] + ")");
                ctx.fillStyle = grd;
                ctx.fillRect((i - 1) * rangeWidth, 0, i * rangeWidth, tfTmpCanvas.height);
            }

            USE_TF_FROMEDITOR = true;
            applyColor();
        }


        var CURRENT_TF_COLORS = [];
        var CURRENT_TF_VALUES = [];
        var MAX_OPACITY = 1.0;

        // Predefined colors for TF editor elements
        var colorBackground = "#aad";
        var colorInactivePoint = "hsb(240°, 1, 1)";
        var colorLine = "hsb(200°, 0.5, 1.0)";
        var colorActivePoint = "hsb(140°, 1, 1)";
        var opacityUnderLine = 1.0;

        // Raphael control elements
        var R_TF_CONTROLPOINTAREAS;
        var R_TF_CONTROLPOINTBUTTONS;

        function createTFEditor(nControlPoints) {
            if (R_TF_EDITOR !== undefined) {
                R_TF_EDITOR.clear();
                R_TF_EDITOR.remove();
            }
            R_TF_EDITOR = Raphael("tfEditorHolder", 512, 75);
            var TF_WIDTH = R_TF_EDITOR.width;
            var TF_HEIGHT = R_TF_EDITOR.height;
            R_TF_EDITOR.rect(0, 0, TF_WIDTH, TF_HEIGHT).attr({fill: colorBackground, stroke: "none"});
            var X = [];
            var Y = [];
            R_TF_CONTROLPOINTAREAS = R_TF_EDITOR.set();
            R_TF_CONTROLPOINTBUTTONS = R_TF_EDITOR.set();
            var isDrag = -1;
            var start = null;
            var unhighlight = function () {
            };
            var R_SPACE_BETWEEN_POINTS;
            var R_TF_UNDERLINE;
            var R_TF_LINE;

            function initTFWithBWGradient() {
                CURRENT_TF_VALUES = [];
                CURRENT_TF_COLORS = [];
                for (var i = 0; i < nControlPoints; i++) {
                    CURRENT_TF_VALUES.push((i + 1) * MAX_OPACITY / nControlPoints);
                    var gray = Math.floor(255 * (i) / (nControlPoints - 1));
                    CURRENT_TF_COLORS.push("rgba(" + gray + "," + gray + "," + gray + "," + opacityUnderLine + ")");
                }
                //var colorGradient = ;
                R_SPACE_BETWEEN_POINTS = TF_WIDTH / CURRENT_TF_VALUES.length;
                R_TF_UNDERLINE = R_TF_EDITOR.path().attr({
                    stroke: "none",
                    fill: [0].concat(CURRENT_TF_COLORS).join("-"),
                    opacity: 0
                });
                R_TF_LINE = R_TF_EDITOR.path().attr({stroke: colorLine, "stroke-width": 2});
            }

            function translate(x, y) {
                return [TF_WIDTH / (CURRENT_TF_VALUES.length - 1) * x, TF_HEIGHT - TF_HEIGHT / MAX_OPACITY * y];
            }

            function drawPath(X, Y, W, H) {
                var p = ["M", X[0], Y[0], "R"];
                for (var j = 1; j < X.length; j++) {
                    p.push(X[j], Y[j]);
                }
                var subaddon = "L" + W + "," + H + ",0," + H + "z";
                R_TF_LINE.attr({path: p});
                R_TF_UNDERLINE.attr({path: p + subaddon});
            }


            function initPath() {
                var ii = CURRENT_TF_VALUES.length - 1;
                for (i = 0; i < ii; i++) {
                    var xy = translate(i, CURRENT_TF_VALUES[i]);
                    var xy1 = translate(i + 1, CURRENT_TF_VALUES[i + 1]);
                    var f;
                    X[i] = xy[0];
                    Y[i] = xy[1];
                    (f = function (i, xy) {
                        R_TF_CONTROLPOINTBUTTONS.push(R_TF_EDITOR.circle(xy[0], xy[1], 5).attr({
                            fill: colorInactivePoint,
                            stroke: "none"
                        }));
                        R_TF_CONTROLPOINTAREAS.push(R_TF_EDITOR.circle(xy[0], xy[1], R_SPACE_BETWEEN_POINTS / 2).attr({
                            stroke: "none",
                            fill: "#fff",
                            opacity: 0
                        }).mouseover(function () {
                            if (isDrag + 1) {
                                unhighlight = function () {
                                };
                            } else {
                                R_TF_CONTROLPOINTBUTTONS.items[i].animate({r: 10, fill: colorActivePoint}, 200);
                            }
                        }).mouseout(function () {
                            if (isDrag + 1) {
                                unhighlight = function () {
                                    R_TF_CONTROLPOINTBUTTONS.items[i].animate({r: 5, fill: colorInactivePoint}, 200);
                                };
                            } else {
                                R_TF_CONTROLPOINTBUTTONS.items[i].animate({r: 5, fill: colorInactivePoint}, 200);
                            }
                        }).drag(function (dx, dy) {
                            var start = this.start;
                            start && update(start.i, start.p + dy);
                        }, function (x, y) {
                            this.start = {i: i, m: y, p: Y[i]};
                        }).click(function () {
                            var currentColor = Raphael.color(document.getElementById("html5colorpicker").value);
                            CURRENT_TF_COLORS[i] = "rgba(" + currentColor.r + "," + currentColor.g + "," + currentColor.b + "," + opacityUnderLine + ")";
                            R_TF_UNDERLINE.animate({fill: [0].concat(CURRENT_TF_COLORS).join("-")}, 100);
                            setNewTF(CURRENT_TF_VALUES, CURRENT_TF_COLORS);
                        }));
                        R_TF_CONTROLPOINTAREAS.items[R_TF_CONTROLPOINTAREAS.items.length - 1].node.style.cursor = "move";
                    })(i, xy);
                    if (i == ii - 1) {
                        f(i + 1, xy1);
                    }
                }
                xy = translate(ii, CURRENT_TF_VALUES[ii]);
                X.push(xy[0]);
                Y.push(xy[1]);
            }

            // Handle when a point gets moved
            var update = function (i, d) {
                (d > TF_HEIGHT ) && (d = TF_HEIGHT );
                (d < 0) && (d = 0);
                Y[i] = d;
                CURRENT_TF_VALUES[i] = -1 / MAX_OPACITY * ((Y[i] / TF_HEIGHT) - 1);
                drawPath(X, Y, TF_WIDTH, TF_HEIGHT);
                R_TF_CONTROLPOINTBUTTONS.items[i].attr({cy: d});
                R_TF_CONTROLPOINTAREAS.items[i].attr({cy: d});
                setNewTF(CURRENT_TF_VALUES, CURRENT_TF_COLORS);
            };

            initTFWithBWGradient();
            initPath();
            drawPath(X, Y, TF_WIDTH, TF_HEIGHT);

            return R_TF_EDITOR;
        }

        var ORIGINAL_X3DNODE_HTML;
        var R_TF_EDITOR;
        function bodyonload() {
            // Set handlers for required drop events
            document.getElementById("DropArea").addEventListener("drop", divondrop);
            document.getElementById("DropArea").addEventListener("dragover", divallowdrop);

            var guiWL = new dat.GUI();
            var wlFolder = guiWL.addFolder('W/L');
            var windowCenter = wlFolder.add(x3domcontrols, 'windowCenter', -2500, 5000, 1).listen();
            var windowWidth = wlFolder.add(x3domcontrols, 'windowWidth', 0, 7500, 1).listen();
            windowCenter.onFinishChange(updateWL);
            windowWidth.onFinishChange(updateWL);
            wlFolder.open();

            var tfFolder = guiWL.addFolder('TF Editor options');
            var numberOfHistogramPoints = tfFolder.add(x3domcontrols, 'numberOfHistogramPoints').min(3).max(32).step(1);
            numberOfHistogramPoints.onChange(function (value) {
                R_TF_EDITOR = createTFEditor(value);
                setNewTF(CURRENT_TF_VALUES, CURRENT_TF_COLORS);
            });

            R_TF_EDITOR = createTFEditor(x3domcontrols.numberOfHistogramPoints);
        }
        window.addEventListener("load", bodyonload, false);
    </script>
</head>
<body>

<!-- This DIV is the area where to drop the DICOM files -->
Drop something straight into the following X3DOM canvas.
<div id="DropArea">
    <div id="MyX3DPlaceHolder">
        <!-- X3DOM node -->
        <X3D id="MyX3D" xmlns='http://www.web3d.org/specifications/x3d-namespace' showStat='false' showLog='false'
             width='512px' height='320px'>
            <Scene id="X3DScene">
                <Background skyColor='0.3 0.3 0.3'></Background>
                <Viewpoint description='Default' zNear='0.0001' zFar='100'></Viewpoint>
                <Transform id="volumeTransform">
                    <SegmentedVolumeData id='volume' dimensions='4.0 4.0 4.0' numberOfMaxSegments="2.0">
                        <ImageTextureAtlas containerField='voxels' id="voxelAtlas" numberOfSlices='1' slicesOverX='1'
                                           slicesOverY='1' hideChildren="true">
                            <canvas width='1024' height='1024' id='voxelCanvas'></canvas>
                        </ImageTextureAtlas>
                        <ImageTextureAtlas containerField='segmentIdentifiers' id="segmentAtlas" numberOfSlices='1'
                                           slicesOverX='1'
                                           slicesOverY='1' hideChildren="true">
                            <canvas width='1024' height='1024' id='segmentCanvas'></canvas>
                        </ImageTextureAtlas>
                        <OpacityMapVolumeStyle lightFactor='1.2' opacityFactor='12.0'>
                            <!--ImageTexture containerField='transferFunction' hideChildren="true">
                                <canvas width='256' height='10' id='tfCanvas'></canvas>
                            </ImageTexture-->
                        </OpacityMapVolumeStyle>
                        <ComposedVolumeStyle>
                            <OpacityMapVolumeStyle opacityFactor="40.0" lightFactor="1.2"></OpacityMapVolumeStyle>
                            <EdgeEnhancementVolumeStyle gradientThreshold='1.8'
                                                        edgeColor='1.0 0.5 0.0'></EdgeEnhancementVolumeStyle>
                        </ComposedVolumeStyle>
                    </SegmentedVolumeData>
                </Transform>
            </Scene>
        </X3D>
    </div>
</div>
<script type="application/javascript">
    // Here we pick up the original HTML Code of our X3D Node
    // Here we pick up the original HTML Code of our X3D Node
    ORIGINAL_X3DNODE_HTML = document.getElementById("MyX3DPlaceHolder").innerHTML;
</script>

<!-- The following div is made invisible in order to hide temporary images needed for atlas and TF computation -->
<div id="InvisibleDiv" style="display:none;background:#888888;width:50%;height:50%">
    <canvas width='256' height='10' id='tfCanvas'></canvas>
    <canvas width='256' height='10' id="tfTmpCanvas"></canvas>
    <canvas width='32' height='32' id="tmpCanvas"></canvas>
    <div id="fullHistogramHolder" style="width:512px;height:100px;display:none;">
        <canvas id="fullHistogramCanvas" width="255" height="100"></canvas>
    </div>
</div>

<div id="tfEditor">
    <div id="tfEditorHolder"></div>
    <input id="html5colorpicker" value="#ffff00" type="color">
</div>
<div class="progress-bar" role="progressbar"
     aria-valuenow="0" arias-valuemin="0" aria-valuemax="100"
     style="width: 0%;" id="execution-progress"></div>
<br>
<img src="../../../imagenes/siggraph.png" class="img-responsive center-block" alt="Input image"
     id="input-image" style="visibility:hidden;">
<img src="../../../imagenes/siggraph.png" class="img-responsive center-block"
     alt="Output image" id="output-image" style="visibility:hidden;">
<div id="input-previews"></div>
<div id="output-previews"></div>
</body>
</html>
